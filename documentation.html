---
layout: main
title: Home
section: documentation
---
<div class="container">

  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Initalizing an instance of RiakClient</h3>
      <p>
        Everything starts with creating an instance of <code>RiakClient</code>. <code>RiakClient</code>
        takes two core arguments, namely a reference to an <a href="http://akka.io" target="_blank">Akka</a>
        <code>ActorSystem</code> and the location of the Riak node you want to interact with.
      </p>
      <p>
        If your app is not based on Akka and therefor has no access to an initialized actor system,
        you can leave off the <code>ActorSystem</code> argument and one will be created for you
        internally. The location of a riak node can be specified as either an HTTP url pointing
        to root of your Riak node or a combination of a hostname and a port number.
      </p>
      <p>
{% highlight scala %}
// Specifying an existing ActorSystem
val client = RiakClient(actorSystem, "localhost", 80)

// or
val client = RiakClient(actorSystem, "http://riak-node.com/")

// Using an internal ActorSystem
val client = RiakClient("localhost", 80)

// or
val client = RiakClient("http://riak-node.com/")
{% endhighlight %}
      </p>
      <p>
        It is important to note that internally <code>RiakClient</code> uses an
        <a href="http://doc.akka.io/docs/akka/2.1.0/scala/extending-akka.html">Akka extension</a> to ensure there can
        be only one instance of <code>RiakClient</code> per actor system. This means that you can <em>"create"</em>
        as many instances of <code>RiakClient</code> as you want because under the surface they all point at the same
        one.
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>RiakValue and RiakMeta</h3>
      <p>
        Before we can fetch and store values, it might be a good idea to talk about how those values are represented.
      </p>
      <p>
        <code><a href="scaladocs/index.html#com.scalapenos.riak.RiakValue" target="_blank">RiakValue</a></code>
        represents the raw, serialized value stored in Riak and all its associated meta data,
        such as its content type, its vclock, its etag, its last modified timestamp its indexes, etc.
        Most interactions with Riak involve dealing with instances of <code>RiakValue</code> in one way or another.
      </p>
      <p>
        Since dealing with raw, untyped data is usually not what you want when programming in Scala, any
        <code>RiakValue</code> can be transformed into an instance of
        <code><a href="scaladocs/index.html#com.scalapenos.riak.RiakMeta" target="_blank">RiakMeta[T]</a></code>,
        which represents the same Riak meta data as <code>RiakValue</code> but now the raw data has been
        deserialized into some type <code>T</code>. This is accomplished by calling its <code>asMeta[T]</code>
        method.
      </p>
      <p>
{% highlight scala %}
val raw: RiakValue = ...

val meta: RiakMeta[Myclass] = raw.asMeta[MyClass]
{% endhighlight %}
      </p>
      <p>
        The reverse transformation is just as simple. Just call the <code>toriakValue</code> method
        on any instance of <code>RiakMeta</code>.
      </p>
      <p>
{% highlight scala %}
val meta: RiakMeta[Myclass] = raw.asMeta[MyClass]

val raw: RiakValue = meta.toRiakValue
{% endhighlight %}
      </p>
      <p>
        This probably all seems pretty abstract to you. For a more integrated example of how to work with
        <code>RiakValue</code> and <code>RiakMeta</code>, have a look at the <a href="examples.html">Examples</a>
        section.
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Serialization</h3>
      <p>
        Of course, these transformations between raw serialized data and typed deserialized
        data don't happen by themselves. These transformations require compatible instances of the
        <code><a href="scaladocs/index.html#com.scalapenos.riak.RiakSerializer" target="_blank">RiakSerializer[T]</a></code>
        and <code><a href="scaladocs/index.html#com.scalapenos.riak.RiakDeserializer" target="_blank">RiakDeserializer[T]</a></code>
        type classes to be available in implicit scope. Let's have a look at their definitions:
      </p>
      <p>
{% highlight scala %}
/**
 * A RiakSerializer is a type class trait for implementing serialization from some
 * type T to a Tuple2 of raw data (a String) and a ContentType.
 */
@implicitNotFound(msg = "Cannot find RiakSerializer type class for ${T}")
trait RiakSerializer[T] {
  def serialize(t: T): (String, ContentType)
}

/**
 * A RiakDeserializer is a type class trait for implementing deserialization from some
 * raw data (a String) and a ContentType to a type T.
 */
@implicitNotFound(msg = "Cannot find RiakDeserializer type class for ${T}")
trait RiakDeserializer[T] {
  def deserialize(data: String, contentType: ContentType): T
}
{% endhighlight %}
      </p>
      <p>
        <em>riak-scala-client</em> uses <code>String</code> as the lowest level
        encoding, which means binary formats are not currently supported. This was a design choice
        made to keep the API as simple as possible. Please let us know if you would like support
        for binary formats!
      </p>
      <p>
        <em>riak-scala-client</em> comes with out-of-the-box support for (de)serializing
        raw Strings (i.e no serialization at all, using text/plain as the content type) and
        any case classes with an associated <a href="https://github.com/spray/spray-json">spray-json</a>
        <code>RootJsonFormat</code> (using application/json). See the <a href="examples.html">Examples</a>
        section for examples using both <a href="https://github.com/spray/spray-json">spray-json</a>
        and custom serialization.
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Buckets</h3>
      <p>
        Just like in Riak, buckets in <em>riak-scala-client</em> are just a way to namespace your keys.
        You can get a reference to a particular bucket simply by calling the <code>bucket</code> method
        of <code>RiakClient</code>, resulting in an instance of
        <code><a href="scaladocs/index.html#com.scalapenos.riak.RiakBucket" target="_blank">RiakBucket</a></code>.
      </p>
      <p>
{% highlight scala %}
val client = RiakClient(actorSystem, "http://riak-node.com/")

val bucket = client.bucket("my-first-bucket")
{% endhighlight %}
      </p>
      <p>
        Most functionality of <em>riak-scala-client</em> is exposed as methods on a <code>RiakBucket</code>
        as you will see below.
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Fetching</h3>
      <p>
        As you would expect, fetching data from Riak is very simple indeed. Just call the <code>fetch</code>
        method on any bucket with a key fo your choice:
      </p>
      <p>
{% highlight scala %}
val bucket = client.bucket("my-first-bucket")

val value: Future[Option[RiakValue]] = bucket.fetch("some-awesome-key")
{% endhighlight %}
      </p>
      <p>
        As you can see, the return type of <code>fetch</code> is <code>Future[Option[RiakValue]]</code>.
        All operations in <em>riak-scala-client</em> that interact with Riak are non-blocking so all of those
        operations will result in some type of <code>Future</code> being produced. The
        <a href="examples.html">Examples</a> section has lots of examples of how to interact with Futures.
      </p>
      <p>
        Obviously not all keys will be bound to a value in Riak so the <code>Future[Option[RiakValue]]</code>
        returned by <code>fetch</code> wraps an <code>Option[RiakValue]</code>.
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Storing</h3>
      <p>
        bla bla bla
      </p>
      <p>
{% highlight scala %}

{% endhighlight %}
      </p>
      <p>
        bla bla bla
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Conflict Resolution</h3>
      <p>
        bla bla bla
      </p>
      <p>
{% highlight scala %}

{% endhighlight %}
      </p>
      <p>
        bla bla bla
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Secondary Indexes (2i)</h3>
      <p>
        bla bla bla
      </p>
      <p>
{% highlight scala %}

{% endhighlight %}
      </p>
      <p>
        bla bla bla
      </p>
    </div>

    <div class="span1"></div>
  </div>



  <div class="row">
    <div class="span1"></div>

    <div class="span10">
      <h3>Bucket Properties</h3>
      <p>
        Next to the obvious methods for fetching, storing, and deleting values, <code>RiakBucket</code> also
        exposes methods for getting and setting common bucket properties. Some examples:
      </p>
      <p>
{% highlight scala %}
// Get all bucket properties at once
val props: Future[RiakBucketProperties] = bucket.properties

// get an individual property
val allowSiblings: Future[Boolean] = bucket.allowSiblings
{% endhighlight %}
      </p>
      <p>
        See the Scaladocs for
        <code><a href="scaladocs/index.html#com.scalapenos.riak.RiakBucket" target="_blank">RiakBucket</a></code> and
        <code><a href="scaladocs/index.html#com.scalapenos.riak.RiakBucketProperties" target="_blank">RiakBucketProperties</a></code>
        for the full set of supported bucket properties.
      </p>
    </div>

    <div class="span1"></div>
  </div>

  <div class="row">
    <div class="span12"></div>
  </div>

</div> <!-- /container -->
